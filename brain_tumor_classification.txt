# -----------------------------
# 1.Import Required Libraries
# -----------------------------
import os
import cv2
import numpy as np
from PIL import Image
import tensorflow as tf
from tensorflow.keras.utils import normalize
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Activation, Dropout, Flatten, Dense
# -----------------------------
# 2.Load Dataset
# -----------------------------
import os
print(os.getcwd())

Output:
C:\Users\

print("Current Directory:", os.getcwd())
Output:
Current Directory: C:\Users\

os.chdir(r"D:\")

print("Current Directory:", os.getcwd())
Output:
Current Directory: D:\

--
image_directory = 'datasets/'

no_tumor_images = os.listdir(image_directory + 'no/')
yes_tumor_images = os.listdir(image_directory + 'yes/')

dataset = []
labels = []

INPUT_SIZE = 64

--
# Load 'no tumor' images
for image_name in no_tumor_images:
    if image_name.endswith('.jpg'):
        img_path = os.path.join(image_directory, 'no', image_name)
        img_cv = cv2.imread(img_path)
        if img_cv is not None:
            img = Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB))
            img = img.resize((INPUT_SIZE, INPUT_SIZE))
            dataset.append(np.array(img))
            labels.append(0)

--
# Load 'yes tumor' images
for image_name in yes_tumor_images:
    if image_name.endswith('.jpg'):
        img_path = os.path.join(image_directory, 'yes', image_name)
        img_cv = cv2.imread(img_path)
        if img_cv is not None:
            img = Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB))
            img = img.resize((INPUT_SIZE, INPUT_SIZE))
            dataset.append(np.array(img))
            labels.append(1)
# -----------------------------
# 3.Data Preprocessing
# -----------------------------
dataset = np.array(dataset)
labels = np.array(labels)

x_train, x_test, y_train, y_test = train_test_split(dataset, labels, test_size=0.2, random_state=0)

x_train = normalize(x_train, axis=1)
x_test = normalize(x_test, axis=1)

# -----------------------------
# 4.Build CNN Model
# -----------------------------
from tensorflow.keras.layers import Input

model = Sequential()
model.add(Input(shape=(INPUT_SIZE, INPUT_SIZE, 3)))

model.add(Conv2D(32, (3, 3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(32, (3, 3), kernel_initializer='he_uniform'))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), kernel_initializer='he_uniform'))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())
model.add(Dense(64))
model.add(Activation('relu'))
model.add(Dropout(0.5))
model.add(Dense(1))
model.add(Activation('sigmoid'))

# -----------------------------
# 5.Compile Model
# -----------------------------
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# -----------------------------
# 6.Train Model
# -----------------------------
model.fit(x_train, y_train, batch_size=16, epochs=10, validation_split=0.1)

Output:
Epoch 1/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 6s 15ms/step - accuracy: 0.7088 - loss: 0.5777 - val_accuracy: 0.8875 - val_loss: 0.3601
Epoch 2/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.8930 - loss: 0.3051 - val_accuracy: 0.9105 - val_loss: 0.2072
Epoch 3/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9464 - loss: 0.1598 - val_accuracy: 0.9437 - val_loss: 0.1400
Epoch 4/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9626 - loss: 0.1116 - val_accuracy: 0.9642 - val_loss: 0.1299
Epoch 5/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9716 - loss: 0.0773 - val_accuracy: 0.9616 - val_loss: 0.1099
Epoch 6/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9863 - loss: 0.0472 - val_accuracy: 0.9668 - val_loss: 0.1261
Epoch 7/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9861 - loss: 0.0471 - val_accuracy: 0.9693 - val_loss: 0.0686
Epoch 8/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9862 - loss: 0.0368 - val_accuracy: 0.9719 - val_loss: 0.0761
Epoch 9/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9941 - loss: 0.0177 - val_accuracy: 0.9668 - val_loss: 0.1103
Epoch 10/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9939 - loss: 0.0183 - val_accuracy: 0.9642 - val_loss: 0.0893
<keras.src.callbacks.history.History at 0x26246c53230>

# -----------------------------
# 7.Evaluate
# -----------------------------
loss, accuracy = model.evaluate(x_test, y_test)
print(f"Test Accuracy: {accuracy*100:.2f}%")

Output:
31/31 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 0s 10ms/step - accuracy: 0.9818 - loss: 0.0842
Test Accuracy: 97.65%

# -----------------------------
# 8.Save Model
# -----------------------------
model.save("brain_tumor_cnn_model.keras")

# -----------------------------
# 9.Load Model
# -----------------------------
from tensorflow.keras.models import load_model
import numpy as np

# Model Load
model = load_model("brain_tumor_cnn_model.keras")
print("âœ… Model loaded successfully!")

Output:
âœ… Model loaded successfully!

--
# Dummy input to test prediction 
dummy_input = np.random.rand(1, 64, 64, 3)  # Shape = same as your model input
prediction = model.predict(dummy_input)

Output:
1/1 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 0s 135ms/step

--
print("Prediction shape:", prediction.shape)
print("Prediction output:", prediction)

Output:
Prediction shape: (1, 1)
Prediction output: [[0.07524563]]

# Once again Model Load 
from tensorflow.keras.models import load_model
import numpy as np

# Model Load
model = load_model("brain_tumor_cnn_model.keras")
print("âœ… Model loaded successfully!")

Output:
âœ… Model loaded successfully!


# -----------------------------
# 10. âš ï¸ What Can Be Improved
# -----------------------------

# -----------------------------
# ğŸ”¸ 1. Check for Overfitting
# -----------------------------
âœ… 1. Plot Training vs Validation Loss and Accuracy
This is the most common and visual way to detect overfitting.
âœï¸ Modify your training code to include a History object:


history = model.fit(
    x_train, y_train,
    batch_size=16,
    epochs=10,
    validation_split=0.1
)

Output:
Epoch 1/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 5s 15ms/step - accuracy: 0.9936 - loss: 0.0185 - val_accuracy: 0.9770 - val_loss: 0.0543
Epoch 2/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9956 - loss: 0.0154 - val_accuracy: 0.9668 - val_loss: 0.0851
Epoch 3/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9958 - loss: 0.0130 - val_accuracy: 0.9719 - val_loss: 0.0851
Epoch 4/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 5s 14ms/step - accuracy: 0.9972 - loss: 0.0092 - val_accuracy: 0.9693 - val_loss: 0.1570
Epoch 5/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9818 - loss: 0.0507 - val_accuracy: 0.9642 - val_loss: 0.0962
Epoch 6/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9982 - loss: 0.0064 - val_accuracy: 0.9744 - val_loss: 0.1283
Epoch 7/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9990 - loss: 0.0039 - val_accuracy: 0.9719 - val_loss: 0.1845
Epoch 8/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9926 - loss: 0.0203 - val_accuracy: 0.9642 - val_loss: 0.0934
Epoch 9/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9982 - loss: 0.0058 - val_accuracy: 0.9719 - val_loss: 0.1049
Epoch 10/10
220/220 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 3s 14ms/step - accuracy: 0.9996 - loss: 0.0017 - val_accuracy: 0.9719 - val_loss: 0.1160


# -----------------------------
# ğŸ“ˆ 2. Plot the Graphs
# -----------------------------
Add this code after training to plot the loss and accuracy curves:

import matplotlib.pyplot as plt

# Accuracy plot
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.grid(True)
plt.show()

# Loss plot
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)
plt.show()


--##
âœ… How to Interpret the Graphs

Observation :

âœ… Training & validation curves both improve and stay close. 
What It Means - Model is generalizing well.

âš ï¸ Validation accuracy plateaus or drops while training accuracy keeps increasing. 
What It Means - Overfitting.

âš ï¸ Validation loss increases while training loss decreases. 
What It Means - Overfitting

# -----------------------------
# ğŸ§ª Evaluate on Test Set
# -----------------------------
# Even if val accuracy looks fine, check test set accuracy:

loss, accuracy = model.evaluate(x_test, y_test)
print(f"Test Accuracy: {accuracy * 100:.2f}%")

Output:

31/31 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 0s 9ms/step - accuracy: 0.9853 - loss: 0.1036
Test Accuracy: 98.26%

âœ… This is Overfitting Metric Value

Training Accuracy 
Validation Accuracy 
est Accuracy 98.06% âœ…

# -----------------------------
# ğŸ”¸ 2. Data Augmentation
# -----------------------------
from tensorflow.keras.preprocessing.image import ImageDataGenerator

datagen = ImageDataGenerator(
    rotation_range=20,
    zoom_range=0.15,
    width_shift_range=0.1,
    height_shift_range=0.1,
    horizontal_flip=True,
)
datagen.fit(x_train)


# -----------------------------
# ğŸ”¸ 3. Class Balance Check
# -----------------------------
from sklearn.utils import class_weight
class_weights = class_weight.compute_class_weight('balanced', classes=np.unique(y_train), y=y_train)

# -----------------------------
# ğŸ”¸ 4. Confusion Matrix & Metrics
# -----------------------------
from sklearn.metrics import classification_report, confusion_matrix

y_pred = model.predict(x_test)
y_pred = (y_pred > 0.5).astype("int32")

print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

Output:

31/31 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 0s 11ms/step
[[318  10]
 [  7 643]]

--
precision    recall  f1-score   support

           0       0.98      0.97      0.97       328
           1       0.98      0.99      0.99       650

    accuracy                           0.98       978
   macro avg       0.98      0.98      0.98       978
weighted avg       0.98      0.98      0.98       978
--
Predicted No Tumor	Predicted Tumor
Actual No	319 (True Negatives)	9 (False Positives)
Actual Tumor	10 (False Negatives)	640 (True Positives)
--
Metric	Class 0 (No Tumor)	Class 1 (Tumor)
Precision	0.97	0.99
Recall	0.97	0.98
F1-score	0.97	0.99
Support	328	650
--
Metric	Insight
Precision (1)	99% â€” Very few false positives (model rarely says â€œtumorâ€ when it's not). âœ…
Recall (1)	98% â€” Very few false negatives (model rarely misses tumors). âœ…
F1-score	Balanced, shows strong performance on both classes. âœ…
Overall Accuracy	98% on test set â€” consistent with training and validation. âœ…
--
from tensorflow.keras.models import load_model
import numpy as np
--
# Model Load
model = load_model("brain_tumor_cnn_model.keras")
print("âœ… Model loaded successfully!")

Output:
âœ… Model loaded successfully!

# -----------------------------
#ğŸ” 1. Integrate Data Augmentation into Training
# -----------------------------
# trained the model with augmented data

# Instead of model.fit(), use .flow() to get augmented data batches
history = model.fit(
    datagen.flow(x_train, y_train, batch_size=16),
    epochs=10,
    validation_data=(x_test, y_test)
)

Output:
Epoch 1/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9625 - loss: 0.1049 - val_accuracy: 0.9898 - val_loss: 0.0309
Epoch 2/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9684 - loss: 0.0902 - val_accuracy: 0.9888 - val_loss: 0.0336
Epoch 3/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 28ms/step - accuracy: 0.9744 - loss: 0.0722 - val_accuracy: 0.9867 - val_loss: 0.0395
Epoch 4/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9754 - loss: 0.0738 - val_accuracy: 0.9898 - val_loss: 0.0250
Epoch 5/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 28ms/step - accuracy: 0.9697 - loss: 0.0855 - val_accuracy: 0.9683 - val_loss: 0.0729
Epoch 6/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9643 - loss: 0.1003 - val_accuracy: 0.9928 - val_loss: 0.0249
Epoch 7/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9728 - loss: 0.0843 - val_accuracy: 0.9918 - val_loss: 0.0248
Epoch 8/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9738 - loss: 0.0666 - val_accuracy: 0.9928 - val_loss: 0.0194
Epoch 9/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9745 - loss: 0.0723 - val_accuracy: 0.9928 - val_loss: 0.0156
Epoch 10/10
245/245 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 7s 29ms/step - accuracy: 0.9759 - loss: 0.0662 - val_accuracy: 0.9949 - val_loss: 0.0161

âœ… This will improve generalization and reduce overfitting slightly more.

ğŸ” Model Summary with Augmentation
Final Accuracy: ~97.5% (train), ~99.5% validation

Validation Loss: Very low (~0.0156)

âœ… No signs of overfitting â€” great generalization

âœ… Data augmentation worked well

# -----------------------------
# ğŸ–¼ï¸ 2. Build a Simple Prediction Pipeline
# -----------------------------
import os
import cv2
import numpy as np
from tensorflow.keras.models import load_model
from PIL import Image

# Load trained model
model = load_model("brain_tumor_cnn_model.keras")

# Set base dataset directory
base_dir = r"D:\..\.\..\datasets"

# Choose which image to predict
# Examples:
# From 'no' folder: os.path.join(base_dir, "no", "0.jpg")
# From 'yes' folder: os.path.join(base_dir, "yes", "1.jpg")

image_path = os.path.join(base_dir, "yes", "1.jpg")  # ğŸ” Change filename as needed

# Function to preprocess and predict image
def predict_image(image_path):
    if not os.path.exists(image_path):
        print(f"âŒ File does not exist: {image_path}")
        return

    # Load and convert image
    img_cv = cv2.imread(image_path)
    img_rgb = cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB)
    img_resized = cv2.resize(img_rgb, (64, 64))
    img_normalized = img_resized / 255.0
    img_input = np.expand_dims(img_normalized, axis=0)  # Add batch dimension

    # Predict
    prediction = model.predict(img_input)[0][0]
    label = "Tumor" if prediction > 0.5 else "No Tumor"
    confidence = prediction if prediction > 0.5 else 1 - prediction

    print(f"ğŸ§  Prediction: {label}")
    print(f"âœ… Confidence: {confidence:.2f}")

# Run the prediction
predict_image(image_path)

Output:
1/1 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 0s 122ms/step
ğŸ§  Prediction: Tumor
âœ… Confidence: 1.00

# -----------------------------
#âœ… Output Summary
ğŸ§  Prediction: Tumor âœ… Confidence: 1.00

âœ… Model successfully loaded and processed the MRI image.

âœ… It confidently predicted "Tumor" with 100% certainty (Confidence = 1.00).

# -----------------------------
#ğŸ¯ What Accomplished

Step	Status
Load trained model	âœ… Done
Preprocess MRI image	âœ… Done
Predict with CNN model	âœ… Done
Output label + confidence âœ… Done

# -----------------------------






